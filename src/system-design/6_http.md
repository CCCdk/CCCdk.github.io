# 7. HTTP

在本文中，我们将深入探讨应用层协议的复杂性，重点讨论 **客户端-服务器模型**、**远程过程调用（RPC）**，以及最常用的协议：**HTTP** 和 **WebSocket**。

## 客户端-服务器模型

**客户端-服务器模型** 是许多网络应用的基础。其核心思想是客户端（通常是桌面或手机等终端设备）向服务器发起请求，服务器处理这些请求并返回响应。这种交互方式虽然简单，但构成了现代 Web 的基础。

```ascii
   +---------+        请求            +------------+
   |  客户端  |  ------------------>  |    服务器   |
   | (浏览器) |  <------------------  |(google.com)|
   +---------+        响应            +------------+
```

在这个模型中，**客户端** 是发起请求的一方，**服务器** 是处理请求并做出响应的一方。然而，需要注意的是，客户端不一定总是像浏览器这样的面向用户的应用。它也可以是另一个服务器，这时就会出现所谓的 **服务器到服务器的请求**。

例如，当你访问 `google.com` 时，浏览器（客户端）会向 Google 的服务器发送请求。但在 Google 的基础设施中，这些服务器可能会与其他服务器通信以完成你的请求，其中一台服务器充当客户端，另一台作为服务器。

## 远程过程调用（RPC）

在分布式计算中，一个重要的概念是 **远程过程调用（RPC）**。它允许一台计算机上的代码像在本地计算机上执行一样，在远程计算机上执行一个过程（或函数）。这个术语可能听起来有些过时，但它对于理解许多现代应用协议至关重要。

考虑一个场景，你正在访问 `YouTube.com`，浏览器需要获取一份推荐视频的列表。生成这个列表的代码位于 YouTube 的服务器上，而不是你的本地计算机。通过 RPC，浏览器向服务器发送请求，要求在服务器上执行该代码，服务器返回数据。

```ascii
   +---------+        RPC 请求         +---------------+
   |  客户端  |  ------------------->  |    服务器      |
   | (浏览器) |  <-------------------  |(YouTube 服务器)|
   +---------+        RPC 响应         +---------------+
```

虽然“RPC”这一术语比较宽泛，但大多数现代应用协议，包括 **HTTP** 和 **WebSocket**，可以被看作是 RPC 的专门形式。

## HTTP

**超文本传输协议（HTTP）** 是万维网的基石。它是一个 **应用层协议**，建立在 **互联网协议（IP）** 和 **传输控制协议（TCP）** 之上。HTTP 是一个 **请求-响应** 协议，即客户端发送请求，服务器做出响应。

```ascii
   +---------+        HTTP 请求         +-----------+
   |  客户端  |   ------------------->  |    服务器  |
   | (浏览器) |   <-------------------  |(Web 服务器)|
   +---------+        HTTP 响应         +-----------+
```

HTTP 基于 **无状态** 模型运行，意味着每个请求都是独立的，服务器不会保留来自同一客户端的先前请求信息，这使得协议简单，但也要求额外的机制来管理会话。

### 1. HTTP 请求结构

一个 HTTP 请求包括两个主要部分：

- **头部 Header**：关于请求的元数据，如方法（`GET`、`POST` 等）、目标 URL、用户代理和接受的内容类型等。
- **主体 Body**：请求中实际发送的数据（并不总是存在）。

### 2. 常见的 HTTP 方法

- **GET**: 用于从服务器获取资源。GET 请求一般不包含请求体（body）。
- **POST**: 用于将数据发送到服务器，通常用于创建资源。POST 请求通常包含请求体。
- **PUT**: 用于更新服务器上的现有资源。PUT 请求包含资源的完整更新数据。
- **DELETE**: 用于删除服务器上的资源。
- **HEAD**: 类似于 GET 请求，但是服务器只返回响应头而不返回实体内容。通常用于获取元数据。
- **OPTIONS**: 请求服务器支持哪些 HTTP 方法。服务器返回支持的方法列表。
- **PATCH**: 用于对资源进行部分更新，类似于 PUT，但通常只发送需要更新的部分。

### 3. HTTP 状态码

HTTP 状态码是服务器响应中的一个关键部分，用于指示请求的结果。状态码被分为五类：

- **1xx (Informational)**: 信息性状态码，表示请求已被接收，继续处理。例如：`100 Continue`。
- **2xx (Successful)**: 成功的状态码，表示请求已成功处理。例如：`200 OK` 表示请求成功，`201 Created` 表示成功创建了一个新资源。
- **3xx (Redirection)**: 重定向状态码，表示需要客户端进一步操作。例如：`301 Moved Permanently` 表示资源已永久移至新位置。
- **4xx (Client Error)**: 客户端错误状态码，表示客户端请求有错误。例如：`404 Not Found` 表示请求的资源不存在。
- **5xx (Server Error)**: 服务器错误状态码，表示服务器未能处理请求。例如：`500 Internal Server Error` 表示服务器处理请求时出错。

这些代码为开发者提供了重要反馈，指示是客户端的错误还是服务器遇到的问题。

### 4. 请求头与响应头

HTTP 请求和响应的头部包含了大量元数据，下面是一些常见的请求头和响应头字段：

- **请求头字段**：
  - `User-Agent`: 浏览器或客户端的身份标识。
  - `Accept`: 客户端支持的内容类型（如 `text/html`、`application/json`）。
  - `Authorization`: 用于传递认证信息（如 Basic 或 Bearer Token）。
  - `Content-Type`: 请求体的类型（如 `application/json` 或 `multipart/form-data`）。
- **响应头字段**：
  - `Content-Type`: 响应体的数据类型。
  - `Set-Cookie`: 用于服务器向客户端发送 Cookie。
  - `Cache-Control`: 控制缓存行为（如 `no-cache`，`max-age=3600`）。
  - `Location`: 在重定向请求中，指示资源的新位置。

### 5. HTTP/1.1 VS HTTP/2 VS HTTP/3

HTTP/1.1 是 HTTP 协议的广泛使用版本，但它存在一些性能瓶颈，尤其是在高延迟的网络环境下。HTTP/2 是一个更新的版本，旨在提高效率：

- **多路复用**: HTTP/2 允许多个请求和响应共享一个 TCP 连接，避免了 HTTP/1.1 中的连接阻塞问题。
- **头部压缩**: HTTP/2 使用 HPACK 压缩请求和响应头，减少了传输数据的大小。
- **服务器推送**: HTTP/2 允许服务器在客户端请求之前主动推送资源，减少了页面加载时间。

HTTP/3 是第三个主要版本的 HTTP 协议，与其前任 HTTP/1.1 和 HTTP/2 不同，在 HTTP/3 中，将弃用 TCP 协议，改为使用基于 UDP 协议的 QUIC 协议实现。此变化主要为了解决 HTTP/2 中存在的队头阻塞问题。由于 HTTP/2 在单个 TCP 连接上使用了多路复用，受到 TCP 拥塞控制的影响，少量的丢包就可能导致整个 TCP 连接上的所有流被阻塞。

### 6. HTTPS VS HTTP

HTTPS 是基于 HTTP 的安全版本，通过 SSL/TLS 协议对数据进行加密，从而保证数据传输的安全性。HTTPS 使用证书来验证服务器的身份，防止中间人攻击和数据篡改。

### 7. 持久连接与连接复用

- **持久连接**: HTTP/1.1 引入了持久连接（也叫做 keep-alive），允许在同一 TCP 连接上发送多个请求和响应，而不需要每次都建立新的连接。
- **连接复用**: HTTP/2 进一步优化了连接复用，允许多个请求和响应在一个连接中并行传输，提高了效率。

### 8. 缓存机制

HTTP 协议内建了缓存机制，用于减少对服务器的请求并提高响应速度。缓存控制通常由以下几种机制实现：

- **Cache-Control**: 用于指定缓存的行为，例如 `max-age` 表示资源可以缓存的最大时间。
- **ETag**: 服务器为资源生成的唯一标识符，用于检查缓存是否过期。
- **Last-Modified**: 资源的最后修改时间，用于判断资源是否被更新。

这些机制帮助提高 Web 应用的性能，并减少服务器负载。

---

## WebSocket

虽然 HTTP 非常适合传统的请求-响应交互，但它并不适合实时通信。这时，**WebSocket** 就显得尤为重要。WebSocket 提供了一个全双工的通信通道，通过一个单一且长期存在的连接，实现客户端和服务器之间的实时数据交换。

```ascii
   +---------+       WebSocket 连接       +---------+
   |  客户端  | <-----------------------> |  服务器  |
   +---------+                           +---------+
```

WebSocket 特别适用于实时聊天、实时通知或在线游戏等应用场景，其中客户端和服务器需要持续交换数据，而不需要每次建立新的 HTTP 连接。

我们将在下一节详细讲解 WebSocket 相关的内容。

---

## 参考文献

- [MDN Web Docs on HTTP](https://developer.mozilla.org/en-US/docs/Web/HTTP)
- [HTTP/2: The Introduction](https://developers.google.com/web/fundamentals/performance/http2)
- [RFC 7231 - HTTP/1.1](https://datatracker.ietf.org/doc/html/rfc7231)
- [Wikipedia on HTTP/3](https://zh.wikipedia.org/wiki/HTTP/3)
