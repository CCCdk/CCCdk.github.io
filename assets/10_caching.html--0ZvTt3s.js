import{_ as t,r as a,o,c as s,b as e,d as r,e as l,a as n}from"./app-bropoVmL.js";const h="/assets/system-4-bW1UH0z5.png",d={},c=n('<h1 id="_11-缓存" tabindex="-1"><a class="header-anchor" href="#_11-缓存" aria-hidden="true">#</a> 11. 缓存</h1><h2 id="缓存的基本概念" tabindex="-1"><a class="header-anchor" href="#缓存的基本概念" aria-hidden="true">#</a> 缓存的基本概念</h2><h3 id="什么是缓存" tabindex="-1"><a class="header-anchor" href="#什么是缓存" aria-hidden="true">#</a> 什么是缓存？</h3><p>缓存是一种临时存储机制，旨在保存经常使用的数据以便快速访问。缓存可以部署在多个层级，包括客户端（如浏览器缓存）、应用服务器（如内存缓存）和数据库附近（如 Redis、Memcached）。通过缓存，可以在快速存储和访问频繁请求的数据的同时，减轻对底层服务的压力。</p><hr><h3 id="为什么需要缓存" tabindex="-1"><a class="header-anchor" href="#为什么需要缓存" aria-hidden="true">#</a> 为什么需要缓存？</h3><ul><li><strong>提升性能：</strong> 减少冗余计算和频繁的数据访问，提升响应速度。</li><li><strong>降低负载：</strong> 减轻数据库和后端服务的压力，节省计算资源。</li><li><strong>减少延迟：</strong> 缓存通过在本地或更近的存储访问数据，显著缩短响应时间。</li></ul><hr><h3 id="核心指标" tabindex="-1"><a class="header-anchor" href="#核心指标" aria-hidden="true">#</a> 核心指标</h3><ul><li><strong>缓存命中率（Cache Hit Ratio）：</strong> 表示缓存满足请求的比例，命中率高代表缓存利用率高。</li><li><strong>缓存一致性：</strong> 确保缓存和底层数据源的一致性。</li><li><strong>过期时间（TTL, Time-to-Live）：</strong> 数据在缓存中的存活时间，避免长时间保存过时数据。</li></ul><h2 id="缓存的类型与模式" tabindex="-1"><a class="header-anchor" href="#缓存的类型与模式" aria-hidden="true">#</a> 缓存的类型与模式</h2><h3 id="按位置分类" tabindex="-1"><a class="header-anchor" href="#按位置分类" aria-hidden="true">#</a> 按位置分类</h3><ul><li><strong>客户端缓存：</strong> 直接存储在用户设备（如浏览器本地存储、Cookie、Service Worker），适用于静态资源（如图片、CSS、JS 文件）的缓存。</li><li><strong>边缘缓存（CDN）：</strong> 部署在离用户较近的网络节点上，用于分发内容（如视频、静态文件）。</li><li><strong>服务端缓存：</strong> 存储在后端服务器或专用的缓存服务中，如 Redis、Memcached，用于动态数据的缓存。</li></ul><hr><h3 id="按存储内容分类" tabindex="-1"><a class="header-anchor" href="#按存储内容分类" aria-hidden="true">#</a> 按存储内容分类</h3><ul><li><strong>键值对缓存：</strong> 使用键值对存储数据，高效查询。 <ul><li>示例：Redis、Memcached。</li></ul></li><li><strong>对象缓存：</strong> 保存更复杂的结构化数据。 <ul><li>示例：缓存数据库查询结果。</li></ul></li><li><strong>结果缓存：</strong> 缓存特定计算的结果以避免重复执行。 <ul><li>示例：推荐算法的排序结果。</li></ul></li></ul><h2 id="缓存的策略" tabindex="-1"><a class="header-anchor" href="#缓存的策略" aria-hidden="true">#</a> 缓存的策略</h2><h3 id="写入策略" tabindex="-1"><a class="header-anchor" href="#写入策略" aria-hidden="true">#</a> 写入策略</h3><figure><img src="'+h+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ol><li><p><strong>写直达（Write-through）：</strong></p><ul><li>每次写入操作同时更新缓存和底层存储。</li><li><strong>优点：</strong> 缓存和数据源一致性好。</li><li><strong>缺点：</strong> 增加了写操作的延迟。</li></ul></li><li><p><strong>写旁路（Write-around）：</strong></p><ul><li>仅将写操作更新到底层存储，而不更新缓存。</li><li><strong>优点：</strong> 避免缓存污染。</li><li><strong>缺点：</strong> 如果写后立即读，可能导致缓存未命中。</li></ul></li><li><p><strong>写回（Write-back）：</strong></p><ul><li>写入先更新缓存，稍后批量同步到底层存储。</li><li><strong>优点：</strong> 提高了写操作效率。</li><li><strong>缺点：</strong> 存在数据丢失风险（如缓存宕机）。</li></ul></li></ol><hr><h3 id="淘汰策略" tabindex="-1"><a class="header-anchor" href="#淘汰策略" aria-hidden="true">#</a> 淘汰策略</h3>',22),u=e("strong",null,"LRU（Least Recently Used）：",-1),g=e("li",null,"移除最近最少使用的缓存条目，Redis 默认使用 LRU。",-1),_={href:"https://2xiao.github.io/leetcode-js/problem/0146",target:"_blank",rel:"noopener noreferrer"},f=e("strong",null,"LFU（Least Frequently Used）：",-1),b=e("li",null,"移除使用频率最低的缓存条目。",-1),p={href:"https://2xiao.github.io/leetcode-js/problem/0460",target:"_blank",rel:"noopener noreferrer"},x=e("strong",null,"FIFO（First In First Out）：",-1),m=e("li",null,"移除最早加入的缓存条目。",-1),L={href:"https://2xiao.github.io/leetcode-js/problem/0622",target:"_blank",rel:"noopener noreferrer"},R=e("li",null,[e("strong",null,"TTL（Time-to-Live）："),e("ul",null,[e("li",null,"设置缓存的存活时间，到期后自动移除。")])],-1),k=n('<h2 id="缓存的一致性问题" tabindex="-1"><a class="header-anchor" href="#缓存的一致性问题" aria-hidden="true">#</a> 缓存的一致性问题</h2><p>缓存一致性指缓存数据与底层存储之间的同步问题。常见挑战包括：</p><h3 id="一致性模型" tabindex="-1"><a class="header-anchor" href="#一致性模型" aria-hidden="true">#</a> 一致性模型</h3><ul><li><strong>强一致性：</strong> 缓存始终与底层数据保持一致，但开销较高。</li><li><strong>最终一致性：</strong> 允许短暂的不一致，最终达到一致性。</li></ul><hr><h3 id="解决方案" tabindex="-1"><a class="header-anchor" href="#解决方案" aria-hidden="true">#</a> 解决方案</h3><ol><li><strong>失效通知：</strong> 数据更新时通知缓存失效。</li><li><strong>主动刷新：</strong> 定期刷新缓存，确保数据最新。</li><li><strong>双写同步：</strong> 同时写入缓存和底层存储。</li></ol><h2 id="缓存的最佳实践" tabindex="-1"><a class="header-anchor" href="#缓存的最佳实践" aria-hidden="true">#</a> 缓存的最佳实践</h2><h3 id="适用场景" tabindex="-1"><a class="header-anchor" href="#适用场景" aria-hidden="true">#</a> 适用场景</h3><ul><li><strong>读多写少：</strong> 缓存更适合读多写少的场景，如商品详情页面。</li><li><strong>数据稳定：</strong> 适用于短期内不频繁变化的数据。</li></ul><hr><h3 id="配置优化" tabindex="-1"><a class="header-anchor" href="#配置优化" aria-hidden="true">#</a> 配置优化</h3><ul><li><strong>合理设置 TTL：</strong> 根据业务需求调整缓存过期时间，避免频繁失效或长时间保存陈旧数据。</li><li><strong>数据分区：</strong> 对缓存进行分区管理，以隔离不同模块或用户数据。</li></ul><hr><h3 id="监控与调整" tabindex="-1"><a class="header-anchor" href="#监控与调整" aria-hidden="true">#</a> 监控与调整</h3><ul><li><strong>监控命中率：</strong> 及时发现低效的缓存策略。</li><li><strong>调整缓存大小：</strong> 根据系统负载和内存容量动态调整。</li></ul><h2 id="缓存的典型应用" tabindex="-1"><a class="header-anchor" href="#缓存的典型应用" aria-hidden="true">#</a> 缓存的典型应用</h2><ol><li><strong>Web 应用：</strong><ul><li>使用 Redis 缓存用户会话和热点数据，提升性能。</li></ul></li><li><strong>分布式系统：</strong><ul><li>使用分布式缓存（如 Redis Cluster）应对高并发场景。</li></ul></li><li><strong>CDN 服务：</strong><ul><li>缓存静态资源，如图片和视频，加速内容分发。</li></ul></li></ol>',18);function C(T,U){const i=a("ExternalLinkIcon");return o(),s("div",null,[c,e("ul",null,[e("li",null,[u,e("ul",null,[g,e("li",null,[r("详见："),e("a",_,[r("LeetCode 146. LRU 缓存"),l(i)])])])]),e("li",null,[f,e("ul",null,[b,e("li",null,[r("详见："),e("a",p,[r("LeetCode 460. LFU 缓存"),l(i)])])])]),e("li",null,[x,e("ul",null,[m,e("li",null,[r("详见："),e("a",L,[r("LeetCode 622. 设计循环队列"),l(i)])])])]),R]),k])}const v=t(d,[["render",C],["__file","10_caching.html.vue"]]);export{v as default};
