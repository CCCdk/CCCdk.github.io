import{_ as e,o as t,c as s,a}from"./app-zPI8OJ9F.js";const n={},d=a(`<h1 id="_15-sql" tabindex="-1"><a class="header-anchor" href="#_15-sql" aria-hidden="true">#</a> 15. SQL</h1><p>在计算机中，<strong>数据库（Database）</strong> 是一种持久化保存数据的方式，通常分为两类： <strong>SQL 数据库</strong> 和 <strong>NoSQL 数据库</strong>。SQL 是 <strong>Structured Query Language</strong>（结构化查询语言）的简称，它是关系型数据库管理系统（RDBMS）的核心组件，用于高效地查询、插入、更新和管理数据库中的数据。</p><p>RDBMS（如 MySQL、PostgreSQL、SQL Server）通过结构化的方式组织数据，主要依赖 SQL 语言来操作数据。其底层数据结构常使用 <strong>B+ Tree</strong> 进行存储。</p><h2 id="b-tree" tabindex="-1"><a class="header-anchor" href="#b-tree" aria-hidden="true">#</a> B+ Tree</h2><p>B+ Tree 是一种平衡树，用于高效地存储和检索有序数据。B+ Tree 提供快速的搜索、插入、删除操作，并能够很好地支持范围查询和顺序访问，因为其多路平衡特性和磁盘读取优化能力，它被广泛用于数据库索引。</p><p>B+ Tree 的每个节点包含键值及指向子节点的指针，叶子节点按顺序存储数据并相互链接。</p><h3 id="b-tree-的结构特点" tabindex="-1"><a class="header-anchor" href="#b-tree-的结构特点" aria-hidden="true">#</a> B+ Tree 的结构特点</h3><ol><li><p><strong>多路平衡性</strong>：</p><ul><li>B+ Tree 是一种多路搜索树，每个节点可以有多个子节点。</li><li>非叶子节点存储索引（key），而不存储实际数据。</li><li>数据仅存储在叶子节点中。</li></ul></li><li><p><strong>叶子节点链表</strong>：</p><ul><li>所有的叶子节点通过双向链表相连，形成一个有序的链表结构。</li><li>这使得范围查询、顺序遍历非常高效。</li></ul></li><li><p><strong>节点分裂和合并</strong>：</p><ul><li>当节点的存储超出容量时，会触发分裂。</li><li>如果数据量减少导致节点利用率过低，会触发合并操作。</li><li>这种机制保证了树的平衡，使得树的高度保持最小。</li></ul></li><li><p><strong>自平衡特性</strong>：</p><ul><li>B+ Tree 保持平衡，即从根节点到任意叶子节点的路径长度相等。</li><li>这种平衡性使得所有操作的时间复杂度为 <code>O(log n)</code>。</li></ul></li></ol><hr><h3 id="b-tree-的优势" tabindex="-1"><a class="header-anchor" href="#b-tree-的优势" aria-hidden="true">#</a> B+ Tree 的优势</h3><ol><li><strong>快速检索</strong>：保证操作时间复杂度为 <code>O(log n)</code>。</li><li><strong>顺序存取</strong>：通过链表支持高效的区间查询。</li><li><strong>高 IO 效率</strong>：设计与磁盘读取特性匹配，减少随机读取。</li></ol><hr><h3 id="b-tree-示例" tabindex="-1"><a class="header-anchor" href="#b-tree-示例" aria-hidden="true">#</a> B+ Tree 示例</h3><p>假设我们有以下一组数字需要存储在一个 B+ Tree 中：<strong>10, 20, 30, 40, 50, 60, 70, 80</strong></p><ul><li>每个节点最多可存储 <strong>3 个键</strong>，超出容量时需要分裂。</li><li>数据存储在叶子节点中，非叶子节点只存储索引。</li></ul><p>构建过程如下：</p><ol><li><p><strong>插入 10, 20, 30</strong>：</p><ul><li>根节点能容纳 3 个键，无需分裂。</li></ul></li><li><p><strong>插入 40</strong>：</p><ul><li>超出容量，节点分裂成两个：左节点存储 <code>[10, 20]</code>，右节点存储 <code>[30, 40]</code>。</li><li>父节点新增索引 30。</li></ul></li><li><p><strong>插入 50, 60</strong>：</p><ul><li>右节点容量满，再次分裂。左叶节点 <code>[10, 20]</code>，中叶节点 <code>[30, 40]</code>，右叶节点 <code>[50, 60]</code>。</li><li>父节点更新为 <code>[30, 50]</code>。</li></ul></li><li><p><strong>插入 70, 80</strong>：</p><ul><li>插入数据到右叶节点，最终结构完成。</li></ul></li></ol><p>最终的 B+ Tree 如下：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>           [30, 50]
          /    |    \\
  [10, 20]-&gt;[30, 40]-&gt;[50, 60, 70, 80]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>根节点为 <code>[30, 50]</code>：30 是左子树与中子树的分界点，50 是中子树与右子树的分界点。</li><li>叶子节点存储所有数据并通过链表链接。</li></ul><p>此时，如果要查询 35 到 75 的值，过程如下：</p><ol><li>先寻找起点 35，从根节点找到范围属于 [30, 50] 的子树，即中子树 [30, 40]。</li><li>依次遍历链表，找到叶子节点 [30, 40] 和 [50, 60, 70, 80]。</li><li>过滤出属于 35 到 75 范围内的值，返回值：[40, 50, 60, 70]。</li></ol><p>这种设计有效利用了磁盘页的读取特性，减少随机 IO 操作，提升性能。</p><h2 id="sql" tabindex="-1"><a class="header-anchor" href="#sql" aria-hidden="true">#</a> SQL</h2><h3 id="使用示例" tabindex="-1"><a class="header-anchor" href="#使用示例" aria-hidden="true">#</a> 使用示例</h3><p>以电话本为例，数据库中的一个表可以存储如下信息：</p><table><thead><tr><th>ID</th><th>Name</th><th>Phone</th></tr></thead><tbody><tr><td>1</td><td>Alice</td><td>123-456-7890</td></tr><tr><td>2</td><td>Bob</td><td>234-567-8901</td></tr><tr><td>3</td><td>Charlie</td><td>345-678-9012</td></tr></tbody></table><h4 id="查询示例" tabindex="-1"><a class="header-anchor" href="#查询示例" aria-hidden="true">#</a> 查询示例</h4><ol><li><strong>查询所有联系人：</strong><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> PhoneBook<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><strong>查询名字为 Alice 的电话：</strong><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> Phone <span class="token keyword">FROM</span> PhoneBook <span class="token keyword">WHERE</span> Name <span class="token operator">=</span> <span class="token string">&#39;Alice&#39;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><strong>添加新联系人：</strong><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> PhoneBook <span class="token punctuation">(</span>Name<span class="token punctuation">,</span> Phone<span class="token punctuation">)</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">&#39;David&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;456-789-0123&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li></ol><hr><h3 id="两个表之间的查询示例" tabindex="-1"><a class="header-anchor" href="#两个表之间的查询示例" aria-hidden="true">#</a> 两个表之间的查询示例</h3><p>以一个简单的学生和课程管理系统为例，有两个表：<code>students</code> 和 <code>courses</code>。它们通过外键关系连接，展示 <strong>一对多</strong> 的关系。</p><h4 id="表结构" tabindex="-1"><a class="header-anchor" href="#表结构" aria-hidden="true">#</a> 表结构</h4><ol><li><p><code>students</code> 表 (学生信息表)：</p><ul><li><code>id</code>: 学生的唯一 ID</li><li><code>name</code>: 学生姓名</li></ul></li><li><p><code>courses</code> 表 (课程信息表)：</p><ul><li><code>id</code>: 课程的唯一 ID</li><li><code>student_id</code>: 学生的 ID（外键，指向 <code>students</code> 表的 <code>id</code> 列）</li><li><code>course_name</code>: 学生选择的课程名称</li></ul></li></ol><p><strong>表数据示例</strong>：</p><p><strong><code>students</code> 表：</strong></p><table><thead><tr><th>id</th><th>name</th></tr></thead><tbody><tr><td>1</td><td>Alice</td></tr><tr><td>2</td><td>Bob</td></tr><tr><td>3</td><td>Charlie</td></tr></tbody></table><p><strong><code>courses</code> 表：</strong></p><table><thead><tr><th>id</th><th>student_id</th><th>course_name</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>Math</td></tr><tr><td>2</td><td>1</td><td>Science</td></tr><tr><td>3</td><td>2</td><td>History</td></tr><tr><td>4</td><td>3</td><td>Math</td></tr><tr><td>5</td><td>3</td><td>Physics</td></tr></tbody></table><h4 id="查询示例-1" tabindex="-1"><a class="header-anchor" href="#查询示例-1" aria-hidden="true">#</a> 查询示例</h4><ol><li><strong>查询某个学生及其所选课程</strong><br> 例如，查询 <code>Alice</code> 的课程：</li></ol><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> students<span class="token punctuation">.</span>name<span class="token punctuation">,</span> courses<span class="token punctuation">.</span>course_name
<span class="token keyword">FROM</span> students
<span class="token keyword">JOIN</span> courses <span class="token keyword">ON</span> students<span class="token punctuation">.</span>id <span class="token operator">=</span> courses<span class="token punctuation">.</span>student_id
<span class="token keyword">WHERE</span> students<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&#39;Alice&#39;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>结果：</strong></p><table><thead><tr><th>name</th><th>course_name</th></tr></thead><tbody><tr><td>Alice</td><td>Math</td></tr><tr><td>Alice</td><td>Science</td></tr></tbody></table><hr><ol start="2"><li><strong>查询所有学生及其课程</strong></li></ol><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> students<span class="token punctuation">.</span>name<span class="token punctuation">,</span> courses<span class="token punctuation">.</span>course_name
<span class="token keyword">FROM</span> students
<span class="token keyword">JOIN</span> courses <span class="token keyword">ON</span> students<span class="token punctuation">.</span>id <span class="token operator">=</span> courses<span class="token punctuation">.</span>student_id<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>结果：</strong></p><table><thead><tr><th>name</th><th>course_name</th></tr></thead><tbody><tr><td>Alice</td><td>Math</td></tr><tr><td>Alice</td><td>Science</td></tr><tr><td>Bob</td><td>History</td></tr><tr><td>Charlie</td><td>Math</td></tr><tr><td>Charlie</td><td>Physics</td></tr></tbody></table><p>通过建立两个表的关系，可以高效查询一对多的关系数据，甚至扩展到更复杂的场景，比如多对多或嵌套查询。这种设计使得关系型数据库能够灵活应对不同的数据管理需求。</p><h2 id="sql-的核心特性-acid" tabindex="-1"><a class="header-anchor" href="#sql-的核心特性-acid" aria-hidden="true">#</a> SQL 的核心特性：ACID</h2><p>为了确保数据库操作的可靠性，SQL 数据库遵循 <strong>ACID</strong> 属性：</p><h3 id="_1-durability-持久性" tabindex="-1"><a class="header-anchor" href="#_1-durability-持久性" aria-hidden="true">#</a> 1. Durability（持久性）</h3><p>Durability 确保当事务完成后，数据会永久保存在存储设备上，即使系统发生崩溃。</p><p><strong>Redis</strong> 通常不完全符合 Durability，因为它是内存数据库，某些配置下数据可能未写入磁盘。</p><p>事务的典型操作流程：</p><ol><li>开始事务（<code>BEGIN</code>）。</li><li>执行操作（<code>READ</code>、<code>WRITE</code>、<code>UPDATE</code>、<code>DELETE</code>）。</li><li>提交事务（<code>COMMIT</code>）。</li></ol><h3 id="_2-atomicity-原子性" tabindex="-1"><a class="header-anchor" href="#_2-atomicity-原子性" aria-hidden="true">#</a> 2. Atomicity（原子性）</h3><p>原子性确保事务中的所有操作要么全部执行，要么完全回滚。</p><p><strong>示例：银行转账</strong></p><ul><li>A 给 B 转账 500 元时，如果 A 转出成功但 B 账户更新时系统崩溃，A 的 500 元不会消失，而是整个事务回滚：<div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>转账前：A: 1000，B: 500
转账后（崩溃）：A: 1000，B: 500
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><h3 id="_3-isolation-隔离性" tabindex="-1"><a class="header-anchor" href="#_3-isolation-隔离性" aria-hidden="true">#</a> 3. Isolation（隔离性）</h3><p>隔离性确保多个事务同时执行时，其结果与按顺序执行的结果一致。</p><p><strong>示例：多事务并发</strong></p><ul><li>A 给 B 转 500 元，C 给 A 转 200 元。在 A 执行转账后，C 的操作不能影响事务的中间状态。</li></ul><h3 id="_4-consistency-一致性" tabindex="-1"><a class="header-anchor" href="#_4-consistency-一致性" aria-hidden="true">#</a> 4. Consistency（一致性）</h3><p>一致性确保事务前后，数据库都处于合法状态。</p><p><strong>示例：</strong></p><ul><li>如果数据库的规则要求账户余额总和不变，任何事务完成后都必须满足此规则。</li></ul>`,69),i=[d];function l(o,r){return t(),s("div",null,i)}const p=e(n,[["render",l],["__file","14_sql.html.vue"]]);export{p as default};
