import{_ as t,r as i,o as a,c as s,b as e,d as n,e as o,a as d}from"./app-sFySMTnI.js";const l={},c=d(`<h1 id="_7-http" tabindex="-1"><a class="header-anchor" href="#_7-http" aria-hidden="true">#</a> 7. HTTP</h1><p>在本文中，我们将深入探讨应用层协议的复杂性，重点讨论 <strong>客户端-服务器模型</strong>、<strong>远程过程调用（RPC）</strong>，以及最常用的协议：<strong>HTTP</strong> 和 <strong>WebSocket</strong>。</p><h2 id="客户端-服务器模型" tabindex="-1"><a class="header-anchor" href="#客户端-服务器模型" aria-hidden="true">#</a> 客户端-服务器模型</h2><p><strong>客户端-服务器模型</strong> 是许多网络应用的基础。其核心思想是客户端（通常是桌面或手机等终端设备）向服务器发起请求，服务器处理这些请求并返回响应。这种交互方式虽然简单，但构成了现代 Web 的基础。</p><div class="language-ascii line-numbers-mode" data-ext="ascii"><pre class="language-ascii"><code>   +---------+        请求            +------------+
   |  客户端  |  ------------------&gt;  |    服务器   |
   | (浏览器) |  &lt;------------------  |(google.com)|
   +---------+        响应            +------------+
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个模型中，<strong>客户端</strong> 是发起请求的一方，<strong>服务器</strong> 是处理请求并做出响应的一方。然而，需要注意的是，客户端不一定总是像浏览器这样的面向用户的应用。它也可以是另一个服务器，这时就会出现所谓的 <strong>服务器到服务器的请求</strong>。</p><p>例如，当你访问 <code>google.com</code> 时，浏览器（客户端）会向 Google 的服务器发送请求。但在 Google 的基础设施中，这些服务器可能会与其他服务器通信以完成你的请求，其中一台服务器充当客户端，另一台作为服务器。</p><h2 id="远程过程调用-rpc" tabindex="-1"><a class="header-anchor" href="#远程过程调用-rpc" aria-hidden="true">#</a> 远程过程调用（RPC）</h2><p>在分布式计算中，一个重要的概念是 <strong>远程过程调用（RPC）</strong>。它允许一台计算机上的代码像在本地计算机上执行一样，在远程计算机上执行一个过程（或函数）。这个术语可能听起来有些过时，但它对于理解许多现代应用协议至关重要。</p><p>考虑一个场景，你正在访问 <code>YouTube.com</code>，浏览器需要获取一份推荐视频的列表。生成这个列表的代码位于 YouTube 的服务器上，而不是你的本地计算机。通过 RPC，浏览器向服务器发送请求，要求在服务器上执行该代码，服务器返回数据。</p><div class="language-ascii line-numbers-mode" data-ext="ascii"><pre class="language-ascii"><code>   +---------+        RPC 请求         +---------------+
   |  客户端  |  -------------------&gt;  |    服务器      |
   | (浏览器) |  &lt;-------------------  |(YouTube 服务器)|
   +---------+        RPC 响应         +---------------+
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>虽然“RPC”这一术语比较宽泛，但大多数现代应用协议，包括 <strong>HTTP</strong> 和 <strong>WebSocket</strong>，可以被看作是 RPC 的专门形式。</p><h2 id="http" tabindex="-1"><a class="header-anchor" href="#http" aria-hidden="true">#</a> HTTP</h2><p><strong>超文本传输协议（HTTP）</strong> 是万维网的基石。它是一个 <strong>应用层协议</strong>，建立在 <strong>互联网协议（IP）</strong> 和 <strong>传输控制协议（TCP）</strong> 之上。HTTP 是一个 <strong>请求-响应</strong> 协议，即客户端发送请求，服务器做出响应。</p><div class="language-ascii line-numbers-mode" data-ext="ascii"><pre class="language-ascii"><code>   +---------+        HTTP 请求         +-----------+
   |  客户端  |   -------------------&gt;  |    服务器  |
   | (浏览器) |   &lt;-------------------  |(Web 服务器)|
   +---------+        HTTP 响应         +-----------+
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>HTTP 基于 <strong>无状态</strong> 模型运行，意味着每个请求都是独立的，服务器不会保留来自同一客户端的先前请求信息，这使得协议简单，但也要求额外的机制来管理会话。</p><h3 id="_1-http-请求结构" tabindex="-1"><a class="header-anchor" href="#_1-http-请求结构" aria-hidden="true">#</a> 1. HTTP 请求结构</h3><p>一个 HTTP 请求包括两个主要部分：</p><ul><li><strong>头部 Header</strong>：关于请求的元数据，如方法（<code>GET</code>、<code>POST</code> 等）、目标 URL、用户代理和接受的内容类型等。</li><li><strong>主体 Body</strong>：请求中实际发送的数据（并不总是存在）。</li></ul><h3 id="_2-常见的-http-方法" tabindex="-1"><a class="header-anchor" href="#_2-常见的-http-方法" aria-hidden="true">#</a> 2. 常见的 HTTP 方法</h3><ul><li><strong>GET</strong>: 用于从服务器获取资源。GET 请求一般不包含请求体（body）。</li><li><strong>POST</strong>: 用于将数据发送到服务器，通常用于创建资源。POST 请求通常包含请求体。</li><li><strong>PUT</strong>: 用于更新服务器上的现有资源。PUT 请求包含资源的完整更新数据。</li><li><strong>DELETE</strong>: 用于删除服务器上的资源。</li><li><strong>HEAD</strong>: 类似于 GET 请求，但是服务器只返回响应头而不返回实体内容。通常用于获取元数据。</li><li><strong>OPTIONS</strong>: 请求服务器支持哪些 HTTP 方法。服务器返回支持的方法列表。</li><li><strong>PATCH</strong>: 用于对资源进行部分更新，类似于 PUT，但通常只发送需要更新的部分。</li></ul><h3 id="_3-http-状态码" tabindex="-1"><a class="header-anchor" href="#_3-http-状态码" aria-hidden="true">#</a> 3. HTTP 状态码</h3><p>HTTP 状态码是服务器响应中的一个关键部分，用于指示请求的结果。状态码被分为五类：</p><ul><li><strong>1xx (Informational)</strong>: 信息性状态码，表示请求已被接收，继续处理。例如：<code>100 Continue</code>。</li><li><strong>2xx (Successful)</strong>: 成功的状态码，表示请求已成功处理。例如：<code>200 OK</code> 表示请求成功，<code>201 Created</code> 表示成功创建了一个新资源。</li><li><strong>3xx (Redirection)</strong>: 重定向状态码，表示需要客户端进一步操作。例如：<code>301 Moved Permanently</code> 表示资源已永久移至新位置。</li><li><strong>4xx (Client Error)</strong>: 客户端错误状态码，表示客户端请求有错误。例如：<code>404 Not Found</code> 表示请求的资源不存在。</li><li><strong>5xx (Server Error)</strong>: 服务器错误状态码，表示服务器未能处理请求。例如：<code>500 Internal Server Error</code> 表示服务器处理请求时出错。</li></ul><p>这些代码为开发者提供了重要反馈，指示是客户端的错误还是服务器遇到的问题。</p><h3 id="_4-请求头与响应头" tabindex="-1"><a class="header-anchor" href="#_4-请求头与响应头" aria-hidden="true">#</a> 4. 请求头与响应头</h3><p>HTTP 请求和响应的头部包含了大量元数据，下面是一些常见的请求头和响应头字段：</p><ul><li><strong>请求头字段</strong>： <ul><li><code>User-Agent</code>: 浏览器或客户端的身份标识。</li><li><code>Accept</code>: 客户端支持的内容类型（如 <code>text/html</code>、<code>application/json</code>）。</li><li><code>Authorization</code>: 用于传递认证信息（如 Basic 或 Bearer Token）。</li><li><code>Content-Type</code>: 请求体的类型（如 <code>application/json</code> 或 <code>multipart/form-data</code>）。</li></ul></li><li><strong>响应头字段</strong>： <ul><li><code>Content-Type</code>: 响应体的数据类型。</li><li><code>Set-Cookie</code>: 用于服务器向客户端发送 Cookie。</li><li><code>Cache-Control</code>: 控制缓存行为（如 <code>no-cache</code>，<code>max-age=3600</code>）。</li><li><code>Location</code>: 在重定向请求中，指示资源的新位置。</li></ul></li></ul><h3 id="_5-http-1-1-vs-http-2-vs-http-3" tabindex="-1"><a class="header-anchor" href="#_5-http-1-1-vs-http-2-vs-http-3" aria-hidden="true">#</a> 5. HTTP/1.1 VS HTTP/2 VS HTTP/3</h3><p>HTTP/1.1 是 HTTP 协议的广泛使用版本，但它存在一些性能瓶颈，尤其是在高延迟的网络环境下。HTTP/2 是一个更新的版本，旨在提高效率：</p><ul><li><strong>多路复用</strong>: HTTP/2 允许多个请求和响应共享一个 TCP 连接，避免了 HTTP/1.1 中的连接阻塞问题。</li><li><strong>头部压缩</strong>: HTTP/2 使用 HPACK 压缩请求和响应头，减少了传输数据的大小。</li><li><strong>服务器推送</strong>: HTTP/2 允许服务器在客户端请求之前主动推送资源，减少了页面加载时间。</li></ul><p>HTTP/3 是第三个主要版本的 HTTP 协议，与其前任 HTTP/1.1 和 HTTP/2 不同，在 HTTP/3 中，将弃用 TCP 协议，改为使用基于 UDP 协议的 QUIC 协议实现。此变化主要为了解决 HTTP/2 中存在的队头阻塞问题。由于 HTTP/2 在单个 TCP 连接上使用了多路复用，受到 TCP 拥塞控制的影响，少量的丢包就可能导致整个 TCP 连接上的所有流被阻塞。</p><h3 id="_6-https-vs-http" tabindex="-1"><a class="header-anchor" href="#_6-https-vs-http" aria-hidden="true">#</a> 6. HTTPS VS HTTP</h3><p>HTTPS 是基于 HTTP 的安全版本，通过 SSL/TLS 协议对数据进行加密，从而保证数据传输的安全性。HTTPS 使用证书来验证服务器的身份，防止中间人攻击和数据篡改。</p><h3 id="_7-持久连接与连接复用" tabindex="-1"><a class="header-anchor" href="#_7-持久连接与连接复用" aria-hidden="true">#</a> 7. 持久连接与连接复用</h3><ul><li><strong>持久连接</strong>: HTTP/1.1 引入了持久连接（也叫做 keep-alive），允许在同一 TCP 连接上发送多个请求和响应，而不需要每次都建立新的连接。</li><li><strong>连接复用</strong>: HTTP/2 进一步优化了连接复用，允许多个请求和响应在一个连接中并行传输，提高了效率。</li></ul><h3 id="_8-缓存机制" tabindex="-1"><a class="header-anchor" href="#_8-缓存机制" aria-hidden="true">#</a> 8. 缓存机制</h3><p>HTTP 协议内建了缓存机制，用于减少对服务器的请求并提高响应速度。缓存控制通常由以下几种机制实现：</p><ul><li><strong>Cache-Control</strong>: 用于指定缓存的行为，例如 <code>max-age</code> 表示资源可以缓存的最大时间。</li><li><strong>ETag</strong>: 服务器为资源生成的唯一标识符，用于检查缓存是否过期。</li><li><strong>Last-Modified</strong>: 资源的最后修改时间，用于判断资源是否被更新。</li></ul><p>这些机制帮助提高 Web 应用的性能，并减少服务器负载。</p><hr><h2 id="websocket" tabindex="-1"><a class="header-anchor" href="#websocket" aria-hidden="true">#</a> WebSocket</h2><p>虽然 HTTP 非常适合传统的请求-响应交互，但它并不适合实时通信。这时，<strong>WebSocket</strong> 就显得尤为重要。WebSocket 提供了一个全双工的通信通道，通过一个单一且长期存在的连接，实现客户端和服务器之间的实时数据交换。</p><div class="language-ascii line-numbers-mode" data-ext="ascii"><pre class="language-ascii"><code>   +---------+       WebSocket 连接       +---------+
   |  客户端  | &lt;-----------------------&gt; |  服务器  |
   +---------+                           +---------+
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>WebSocket 特别适用于实时聊天、实时通知或在线游戏等应用场景，其中客户端和服务器需要持续交换数据，而不需要每次建立新的 HTTP 连接。</p><p>我们将在下一节详细讲解 WebSocket 相关的内容。</p><hr><h2 id="参考文献" tabindex="-1"><a class="header-anchor" href="#参考文献" aria-hidden="true">#</a> 参考文献</h2>`,48),h={href:"https://developer.mozilla.org/en-US/docs/Web/HTTP",target:"_blank",rel:"noopener noreferrer"},T={href:"https://developers.google.com/web/fundamentals/performance/http2",target:"_blank",rel:"noopener noreferrer"},g={href:"https://datatracker.ietf.org/doc/html/rfc7231",target:"_blank",rel:"noopener noreferrer"},p={href:"https://zh.wikipedia.org/wiki/HTTP/3",target:"_blank",rel:"noopener noreferrer"};function u(P,b){const r=i("ExternalLinkIcon");return a(),s("div",null,[c,e("ul",null,[e("li",null,[e("a",h,[n("MDN Web Docs on HTTP"),o(r)])]),e("li",null,[e("a",T,[n("HTTP/2: The Introduction"),o(r)])]),e("li",null,[e("a",g,[n("RFC 7231 - HTTP/1.1"),o(r)])]),e("li",null,[e("a",p,[n("Wikipedia on HTTP/3"),o(r)])])])])}const H=t(l,[["render",u],["__file","6_http.html.vue"]]);export{H as default};
